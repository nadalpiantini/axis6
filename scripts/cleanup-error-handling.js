#!/usr/bin/env node

/**
 * Cleanup malformed error handling code generated by the automation scripts
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Find files with malformed error handling patterns
function findMalformedFiles() {
  try {
    const result = execSync(
      `grep -r "operation: 'unknown_operation'," . --include="*.ts" --include="*.tsx" -l`,
      { cwd: process.cwd(), encoding: 'utf8' }
    );
    return result.trim().split('\n').filter(Boolean);
  } catch (error) {
    return [];
  }
}

// Clean up specific malformed patterns
function cleanupFile(filePath) {
  if (!fs.existsSync(filePath)) return false;
  
  let content = fs.readFileSync(filePath, 'utf8');
  const originalContent = content;
  
  // Remove duplicated error handling calls
  content = content.replace(/handleError\(error, \{\s*\n\s*operation: '[^']+',\s*\n\s*component: '[^']+',\s*\n\s*userMessage: '[^']+'\s*\n\s*\}\)\s*\n\s*\/\/ handleError\(error, \{[^}]+\}\)/g, (match) => {
    // Extract the first handleError call
    const firstCall = match.match(/handleError\(error, \{\s*\n\s*operation: '[^']+',\s*\n\s*component: '[^']+',\s*\n\s*userMessage: '[^']+'\s*\n\s*\}\)/);
    return firstCall ? firstCall[0] : match;
  });
  
  // Fix console.error references without error variable
  content = content.replace(/console\.error\('([^']+) operation failed:', error\)/g, '// Handled by standardErrorHandler');
  
  // Clean up malformed variable references in CSP file
  content = content.replace(/handleError\(error, \{[^}]*\}\)\s*\.toISOString\(\)\s*\/\/ \}\)/g, '// Error handled by standardErrorHandler');
  
  // Remove orphaned closing braces and comments
  content = content.replace(/\s*\/\/ \}\)\s*$/gm, '');
  content = content.replace(/\s*\}\)\s*\/\/ \}\s*$/gm, '}');
  
  // Fix specific malformed patterns like "handleError(...}).toISOString()"
  content = content.replace(/handleError\([^}]+\}\)\s*\.toISOString\(\)/g, '// Error handled by standardErrorHandler');
  
  // Clean up multiple empty lines
  content = content.replace(/\n\s*\n\s*\n/g, '\n\n');
  
  if (content !== originalContent) {
    fs.writeFileSync(filePath, content);
    return true;
  }
  
  return false;
}

// Remove files with only malformed error handling to regenerate them
function removeProblematicFiles() {
  const problematicPatterns = [
    'handleError(error, {',
    '// handleError(error, {',
    'operation: \'unknown_operation\','
  ];
  
  try {
    const result = execSync(
      `grep -r "// handleError(error, {" . --include="*.ts" --include="*.tsx" -l`,
      { cwd: process.cwd(), encoding: 'utf8' }
    );
    const files = result.trim().split('\n').filter(Boolean);
    
    files.forEach(filePath => {
      const content = fs.readFileSync(filePath, 'utf8');
      // Count malformed patterns
      const malformedCount = content.match(/\/\/ handleError\(error, \{/g)?.length || 0;
      const totalHandleErrors = content.match(/handleError\(/g)?.length || 0;
      
      // If more than 50% are malformed, clean more aggressively
      if (malformedCount > totalHandleErrors / 2) {
        console.log(`âš ï¸  High malformed count in ${filePath}: ${malformedCount}/${totalHandleErrors}`);
      }
    });
  } catch (error) {
    // No malformed files found
  }
}

console.log('ðŸ§¹ Cleaning up malformed error handling code');
console.log('============================================');

const malformedFiles = findMalformedFiles();
console.log(`Found ${malformedFiles.length} files with 'unknown_operation'`);

let cleanedCount = 0;

malformedFiles.forEach(filePath => {
  console.log(`Cleaning: ${filePath}`);
  const cleaned = cleanupFile(filePath);
  if (cleaned) {
    cleanedCount++;
    console.log(`  âœ… Cleaned up malformed patterns`);
  } else {
    console.log(`  âšª No cleanup needed`);
  }
});

// Check for remaining issues
removeProblematicFiles();

console.log(`\nðŸ“Š Cleanup Summary:`);
console.log(`  Files cleaned: ${cleanedCount}`);

// Check if we have any remaining malformed patterns
try {
  const remainingMalformed = execSync(
    `grep -r "// handleError(error, {" . --include="*.ts" --include="*.tsx" | wc -l`,
    { cwd: process.cwd(), encoding: 'utf8' }
  );
  console.log(`  Remaining malformed patterns: ${remainingMalformed.trim()}`);
} catch (error) {
  console.log(`  Remaining malformed patterns: 0`);
}

console.log('\nâœ¨ Error handling cleanup complete!');
console.log('ðŸ’¡ Recommended next steps:');
console.log('  1. Review cleaned files manually');
console.log('  2. Run TypeScript check: npm run type-check');
console.log('  3. Test the application: npm run dev');